# 03-让文本飞

---

- [用grep在文件中搜索文本](#用grep在文件中搜索文本)
- [用cut按列切分文件](#用cut按列切分文件)


---

## 用grep在文件中搜索文本

`grep`能够接受**通配符**和**正则表达式**！

```bash
# grep将match_pattern视为通配符
grep match_pattern filename1 filename2 --color=auto

# grep支持正则表达式
# 通过grep返回匹配的行 通过-o可以只输出文件中匹配到的文本部分
echo this is new line. | grep -o -E "[a-z]+\."
echo this is new line. | egrep -o "[a-z]+\."

# 返回除了包含match_pattern之外的所有行
grep -v match_pattern file

# 统计文本中包含匹配字符串的行数
# 注意返回的是匹配的行数 而不是匹配项的数量
grep -c "text" filename

# 统计匹配项的数量
echo -e "1 2 3 4\nhello\n5 6" | egrep -o "[0-9]" | wc -l

# "-n"输出包含匹配项的行 显示行号
echo -e "1 2 3 4\nhello\n5 6" | grep hello -n

# 忽略匹配样式中的大小写
echo hello world | grep -i "HELLO"

# "-R"递归搜索文件
# 这个很有用 程序员查找某些文本位于那些源码文件中
grep match_pattern . -R -n

# "--include"只在目录中递归搜索某些文件
grep "main" . -R --include *.{c,cpp}
# "--exclude"在递归搜索过程中排除某些文件
grep "main" . -R --exclude "README"
# "--exclude-dir"在递归搜索过程中排除某些目录
grep "main" . -R --exclude-dir dir

# 匹配多个样式
grep -e match_pattern_1 -e match_pattern_2

# 静默模式下grep不向stdout打印任何输出
# 它仅仅运行命令 然后根据命令执行成功与否返回退出状态
grep -q match_pattern filename

# 打印匹配项之前之后的行
# "-B" 之前
seq 10 | grep 5 -B 3
# "-A" 之后
seq 10 | grep 5 -A 3
# "-C" 之前之后
seq 10 | grep 5 -C 3
```

## 用cut按列切分文件

```bash
cat info
NO;NAME;MARK;PERCENT
1;A;10;10
2;B;20;20
3;C;30;30

# "-f"指定要提取的列
# "-d"指定定界符 默认定界符是"\t"
cut -f 1,2 -d ";" info

# 打印除了第3列之外的所有列
cut -f 3 --complement -d ";" info

# "-b"按字节提取 "-c"按字符提取 "-f"按字段提取
# "N-"第N个行尾 "N-M"第N个到第M个 "-M"行首到第M个

# 打印第1个到第5个字符
cut -c 1-5 info
```

