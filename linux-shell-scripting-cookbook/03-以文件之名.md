# 03-以文件之名

------

- [生成任意大小的文件](#生成任意大小的文件)
- [文本文件的交集和差集](#文本文件的交集和差集)
- [创建长路径目录](#创建长路径目录)
- [文件权限](#文件权限)
- [创建不可修改文件](#创建不可修改文件)
- [批量生成空白文件](#批量生成空白文件)
- [符号链接](#符号链接)
- [列举文件类型统计信息](#列举文件类型统计信息)
- [环回文件与挂载](#环回文件与挂载)

------

## 生成任意大小的文件

最简单的创建特定大小文件的方式是`dd`！它会克隆给定的输入内容，然后将一模一样的副本写入到输出！输入可以是`stdin`、设备文件、普通文件，输出可以是`stdout`、设备文件、普通文件！

```bash
# "if"即"inputFile" 默认不指定则为stdin
# "of"即"outputFile" 默认不指定则为stdout
# "/dev/zero"是一个字符设备 不断返回0值字节即"\0"
dd if=/dev/zero of=junk.data bs=1M count=1
```

## 文本文件的交集和差集

`comm A B`的输出有三列，第一列包含只在`A`出现的行，第二列包含只在`B`出现的行，第三列包含`A`和`B`中相同的行！各列以`\t`作为定界符！

```bash
# 交集
# "-x"表示从输出中删除第x列
comm A B -1 -2

# 求差
comm A B -3 | sed 's/^\t//'

# 差集
comm A B -2 -3 # A的差集
comm A B -1 -3 # B的差集
```

## 创建长路径目录

```bash
# 判断文件是否存在（目录也是一种特殊文件）
if [ -e /home/slynux ]; then
fi

# "-p" 忽略已经存在的目录同时创建缺失的部分
mkdir -p /home/slynux/test/hello/big
```

## 文件权限

文件通常与三类权限打交道：用户、用户组、其他！

```bash
# 第一列表明文件类型
# "-" 普通文件
# "d" 目录
# "c" 字符设备
# "b" 块设备
# "l" 符号链接
# "s" 套接字
# "p" 管道

# 用户
-rwx------
# 用户有setuid特殊权限 可出现在执行权限位置
# 表示允许用户以拥有者权限执行
-rwS------

# 用户组
# 用户组有setgid特殊权限 可出现在执行权限位置
# 表示允许用户组以拥有者所在组相同的权限执行
----rwS---

# 其他用户
# 目录（注意！目录）有特殊权限位叫做粘滞位
# 设置粘滞位表示只有owner或root才有权限删除目录中文件 即使用户组和其他用户有写权限也不好使
# 无设置执行权限 & 设置粘滞位 表示为-------rwt
# 有设置执行权限 & 设置粘滞位 表示为-------rwT
```

## 创建不可修改文件

一旦文件被设置为不可修改，任何用户包括`root`都不能修改它，除非不可修改属性先被移除！

```bash
# 设置文件不可修改
chattr +i file
# 移除不可修改属性
chattr -i file
```

## 批量生成空白文件

`touch`命令用来生成空白文件，如果文件存在，则可用它来修改文件时间戳！

```bash
# 创建名为filename的空白文件
touch filename

# 批量生成名字不同的文件
for name in {1..100}.txt
do
touch $name
done

# 更改文件访问时间为当前时间
touch -a existingFile

# 更改文件修改时间为当前时间
touch -m existingFile

# 指定文件时间戳 接受任何标准日期格式
touch -d "Jan 20 2011" filename
```

## 符号链接

* 硬链接和软链接**都不会**将原本档案复制一份
* 硬链接**不能**跨文件系统，软链接可以
* 硬链接**不能**对目录进行链接，软链接可以

```bash
# 在已登录用户的home目录创建一个名为web的符号链接 指向/var/www/
ln -s /var/www/ ~/web

# 打印当前目录下符号链接
1) ls -l | grep "^1" | awk '{ print $8}'
2) find . -type l -print

# 找出与符号链接关联的目标
readlink web
```

## 列举文件类型统计信息

```bash
#!/bin/bash

if [ $# -ne 1 ];
then
  echo $0 basepath;
  echo
fi
path=$1

# declare associative array
declare -A statarray;

# while read line;
# do something
# done< filename
while read line;
do
  ftype=`file -b "$line"`
  let statarray["$ftype"]++;
done< <(find $path -type f -print)

echo ===== File Types and Counts =====
# ${!statarray[@]} return index array
for ftype in "${!statarray[@]}";
do
  echo $ftype : ${statarray["$ftype"]}
done
```

## 环回文件与挂载

通常，我们在存储设备如磁盘中创建**文件系统**，这样的存储设备称为**设备文件**，然后我们将其**挂载**到**挂载点**上使用！而**环回文件**则是**在文件中而非物理设备**中创建的文件系统，我们一样可以将其**挂载**到**挂载点**上！

挂载点是什么？就是一个**目录**，用来作为通过文件系统访问设备内容的路径！

```bash
# 创建1G大小的文件 因为分配存储空间是按照块大小的整数倍 实际文件大于1G
dd if=/dev/zero of=loopback.img bs=1G count=1
# 格式化
mkfs.ext4 loopback.img
# 检查文件系统
sudo file loopback.img
# 将环回文件连接到设备
losetup /dev/loop1 loopback.img
# 将设备挂载到挂载点
mount /dev/loop1 /mnt/loopback
```

```bash
# 卸载
umount mount_point
```

```bash
# 将ISO文件作为环回文件挂载
mkdir /mnt/iso
mount -o loop linux.iso /mnt/iso
```

```bash
# 对挂载设备更改不会立即写入物理设备 只有当缓冲区写满后才会回写
# 利用sync立即应用更改
sync
```

